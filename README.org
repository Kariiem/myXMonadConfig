#+title: XMonad Config
#+author: Karim
#+property: header-args :tangle src/xmonad.hs

* Table of contents :toc:
- [[#xmonad][XMonad]]
  - [[#language-extensions][Language Extensions]]
  - [[#imports][Imports]]
  - [[#variables][Variables]]
  - [[#workspaces][Workspaces]]
  - [[#scratchpads][Scratchpads]]
  - [[#log-hook][Log Hook]]
  - [[#startup-hook][Startup Hook]]
  - [[#event-hook][Event Hook]]
  - [[#manage-hook][Manage Hook]]
  - [[#layout-hook][Layout Hook]]
  - [[#keybindings][Keybindings]]
  - [[#main][Main]]
- [[#xmobar][XMobar]]
  - [[#utils][Utils]]
  - [[#fonts][Fonts]]
  - [[#monitors][Monitors]]
  - [[#main-1][Main]]

* XMonad
[[file:./xmonad.png]]

** Language Extensions
#+begin_src haskell

#+end_src

** Imports
#+begin_src haskell

  -- Builtin
import Data.Map qualified as M
import Data.Monoid
import System.Exit
import System.IO
import Control.Arrow (first, (&&&))
import Data.Ord

  -- Basic
import XMonad
import XMonad.Prelude
import XMonad.StackSet qualified as W

  -- Layouts
import XMonad.Layout.MultiToggle
import XMonad.Layout.MultiToggle.Instances
import XMonad.Layout.ResizableThreeColumns
import XMonad.Layout.Spacing
import XMonad.Layout.Decoration
import XMonad.Layout.SimplestFloat
import XMonad.Layout.Grid
import XMonad.Layout.NoBorders
import XMonad.Layout.Renamed
import XMonad.Layout.ResizableTile
import XMonad.Layout.WindowArranger
import XMonad.Layout.BorderResize
import XMonad.Layout.Tabbed

  -- Actions
import XMonad.Actions.SpawnOn
import XMonad.Actions.MouseResize
import XMonad.Actions.CopyWindow
import XMonad.Actions.CycleWS

  -- Hooks
import XMonad.Hooks.InsertPosition
import XMonad.Hooks.Place
import XMonad.Hooks.ManageDocks
import XMonad.Hooks.StatusBar
import XMonad.Hooks.FadeWindows
import XMonad.Hooks.WorkspaceHistory
import XMonad.Hooks.WindowSwallowing
import XMonad.Hooks.SetWMName
import XMonad.Hooks.StatusBar.PP
import XMonad.Hooks.EwmhDesktops
import XMonad.Hooks.ManageHelpers
  -- Utils
import XMonad.Util.EZConfig
import XMonad.Util.NamedActions
import XMonad.Util.NamedScratchpad
import XMonad.Util.Hacks qualified as Hacks
import XMonad.Util.ClickableWorkspaces
import XMonad.Util.SpawnOnce
import XMonad.Util.Run

  -- MyLib
import Color.Theme
#+end_src


** Variables
#+begin_src haskell
myTerminal :: String
myTerminal = "alacritty"

-- Whether focus follows the mouse pointer.
myFocusFollowsMouse :: Bool
myFocusFollowsMouse = True

-- Whether clicking on a window to focus also passes the click to the window
myClickJustFocuses :: Bool
myClickJustFocuses = False

myModMask :: KeyMask
myModMask = mod4Mask

myNormalBorderColor :: String
myNormalBorderColor = "#5599cc"

myFocusedBorderColor :: String
myFocusedBorderColor = "#55ff99"

myBorderWidth :: Dimension
myBorderWidth = 2

defaultGapSize :: Integer
defaultGapSize = 10

doom_emacsclient :: String
doom_emacsclient = "~/script/run_emacs doom doom-emacs"

vanilla_emacsclient :: String
vanilla_emacsclient = "~/script/run_emacs vanilla vanilla-emacs"

dmenu_run :: String
dmenu_run = "~/Suckless/bin/dmenu_run_history"

sysMonitor :: String
sysMonitor = "btop"
#+end_src


** Workspaces
Workspaces are the tags that appear in the status bar, each tag corresponds to virtual workspace.
#+begin_src haskell
myWorkspaces :: [String]
myWorkspaces = ["home","fecu","www","docs","dev","xmonad","sys-mon"] --map show [1..9::Int]

#+end_src


** Scratchpads
#+begin_src haskell
scratchpads =
  [ -- run htop in xterm, find it by title, use default floating window placement
    NS "notes" "st -e nvim" (title =? "notes") defaultFloating,
    NS
      "stardict"
      "stardict"
      (className =? "Stardict")
      (customFloating $ W.RationalRect (1 / 6) (1 / 6) (2 / 3) (2 / 3))
  ]

#+end_src


** Log Hook
#+begin_src haskell

myLogHook :: X ()
myLogHook =
  workspaceHistoryHook

myFadeHook :: FadeHook
myFadeHook = composeAll []

#+end_src

*** Status bar
This section defines a pretty printer (PP) for the status bar.

#+begin_src haskell
myPP :: PP
myPP =
  def
    { ppCurrent = xmobarColor (colorRed theme) "",
      ppUrgent = xmobarColor (colorGreen theme) (colorBPurple theme),
      ppLayout = xmobarFont 5 . xmobarColor (colorBPurple theme) "" ,
      ppSep = " ",
      ppWsSep = " ",
      ppExtras = [windowCount],
      ppTitle = xmobarColor (colorFore theme) "" . shorten 45,
      ppHidden = xmobarColor (colorCyan theme) "",
      ppHiddenNoWindows = xmobarColor (colorGrey theme) "",
      ppOrder = \(ws : l : t : ex) -> ws : ex ++ l : [t]
    }

windowCount :: X (Maybe String)
windowCount =
  Just
    . xmobarColor (colorGreen theme) ""
    . show
    . length
    . W.integrate'
    . W.stack
    . W.workspace
    . W.current
    . windowset
    <$> get

mySB :: StatusBarConfig
mySB =
  statusBarProp "xmobar" $
    copiesPP (xmobarFont 4 . xmobarColor (colorBlack theme) "") myPP >>= clickablePP

#+end_src


** Startup Hook
Startup hook
Perform an arbitrary action each time xmonad starts or is restarted with mod-q.

`spawnOnce` is called only the first time xmonad is started

`spawn` is called every time xmonad is started
#+begin_src haskell
customXConfig :: XConfig Layout
customXConfig = myXConfig { layoutHook = Layout $ layoutHook myXConfig }

myStartupHook :: X ()
myStartupHook = do
  return () >> yadCheckKeymap customXConfig
             $ concatMap (\(KeySection _ keys) -> keys)
             $ myKeysSections customXConfig
  setWMName "LG3D"
  spawnOnce "sxhkd"
  spawnOnce "emacs --with-profile doom-emacs --daemon &"
  spawnOnce "emacs --with-profile vanilla-emacs --daemon &"
  spawnOnOnce "sys-mon" ("st -e "++ sysMonitor)
  spawn "killall trayer"
  spawnOnce "nm-applet"
  spawnOnce "picom"

  spawn $
     "sleep 2 && trayer --edge top --align right --distance 10 --distancefrom right --distance 5 --distancefrom top \
      \--widthtype request --padding 6 --SetDockType true --SetPartialStrut false --expand true --transparent true --alpha 0 \
      \--tint "
        ++ trayerColor
        ++ " --height 30"


trayerColor = "0x" ++ tail (colorBack theme)
#+end_src


** Event Hook
Defines a custom handler function for X Events. The function should return (All True) if the default handler is to be run afterwards.

#+begin_src haskell
myEventHook :: Event -> X All
myEventHook =
  composeAll
    [ Hacks.windowedFullscreenFixEventHook,
      swallowEventHook (className =? "Alacritty" <||> className =? "Termite") (return True)
    ]
#+end_src


** Manage Hook
Execute arbitrary actions and WindowSet manipulations when managing
a new window. You can use this to, for example, always float a
particular program, or have a client always appear on a particular
workspace.

To find the property name associated with a program, use
> xprop | grep WM_CLASS
and click on the client you're interested in.

To match on the WM_NAME, you can use 'title' in the same way that
'className' and 'resource' are used below.

#+begin_src haskell
myManageHook :: Query (Endo WindowSet)
myManageHook =
  composeAll
    [ manageSpawn,
      insertPosition Below Newer,
      namedScratchpadManageHook scratchpads,
      className =? "jetbrains-idea-ce" --> doFloat,
      className =? "dialog" --> doFloat,
      className =? "download" --> doFloat,
      className =? "notification" --> doFloat,
      className =? "Xmessage" --> doFloat,
      className =? "Yad" -->doCenterFloat,
      placeHook $ withGaps (16, 16, 16, 16) (smart (0.5, 0.5))
    ]

#+end_src


** Layout Hook

#+begin_src haskell
mySpacing :: Integer -> Integer -> l a -> ModifiedLayout Spacing l a
mySpacing i j = spacingRaw False (Border i i i i) True (Border j j j j) True

resizableTiled = renamed [Replace "tall"]
               $ mySpacing defaultGapSize defaultGapSize
               $ ResizableTall 1 (3 / 100) (1 / 2) []

threeColMid = renamed [Replace "threeColMid"]
            $ mySpacing defaultGapSize defaultGapSize
            $ ResizableThreeColMid 1 (3 / 100) (1 / 2) []

threeCol = renamed [Replace "threeCol"]
            $ mySpacing defaultGapSize defaultGapSize
            $ ResizableThreeCol 1 (3 / 100) (1 / 2) []
tabLayout = renamed [Replace "tabs"]
          $ tabbed shrinkText tabLayoutTheme

grid = renamed [Replace "grid"] $ mySpacing defaultGapSize defaultGapSize Grid

full = renamed [Replace "monocle"] $ mySpacing defaultGapSize defaultGapSize Full

myFloat = renamed [Replace "float"]
        . mouseResize
        . borderResize
        . windowArrangeAll
        $ simplestFloat

myLayout = avoidStruts
         . smartBorders
         . mkToggle (NOBORDERS ?? FULL ?? EOT)
         . mkToggle (single MIRROR) $ lll -- . avoidStruts lll
  where
    lll =
            resizableTiled
        ||| threeCol
        ||| threeColMid
        ||| tabLayout
        ||| grid
        ||| full
        ||| myFloat

tabLayoutTheme :: Theme
tabLayoutTheme = def { activeColor = colorBlue theme
                     , inactiveColor = colorGrey theme
                     , activeTextColor = colorFore theme
                     , inactiveTextColor = colorFore theme
                     , fontName = "xft:Ubuntu:bold"
                     , inactiveBorderWidth = 0
                     , activeBorderWidth = 0
                     , urgentBorderWidth = 0
                     , decoHeight = 30
                     }

#+end_src


** Keybindings
To view a list of keybindings, press "M-F1".
*** KeyMap
#+begin_src haskell
data KeySection = KeySection String {-Title-} [(String,NamedAction)] {- keys -}

myKeysSections :: XConfig Layout -> [KeySection]
myKeysSections conf =
  [ KeySection "XMonad Controls"
               [ ("M-q"          , addName "\tRestart XMonad"                $ sbCleanupHook mySB >> spawn "xmonad --restart")
               , ("M-r"          , addName "\tRecompile XMonad"              $ spawn "xmonad --recompile")
               , ("M-S-c"        , addName "\tKill the focused application"  $ kill1)
               , ("M-S-q"        , addName "\tExit XMonad"                   $ io exitSuccess)
               , ("M-S-r"        , addName "\tRefresh XMonad"                $ refresh)
               , ("M-S-b"        , addName "\tShow/Hide status bar"          $ sendMessage ToggleStruts)
               ]
  , KeySection "Dmenu Scripts"
               [ ("M-S-t"        , addName "\tChange color theme"            $ spawn "$XDG_CONFIG_HOME/xmonad/scripts/change_color_theme")
               , ("M-x"          , addName "\tPoweroff prompt "              $ spawn "$XDG_CONFIG_HOME/xmonad/scripts/power_options")
               , ("M-p"          , addName "\tDmenu app launcher"            $ spawn dmenu_run)
               , ("M-o"          , addName "\tNavigate your pdf history"     $ spawn "$XDG_CONFIG_HOME/xmonad/scripts/pdf_history")
               ]
  , KeySection "Applications"
               [ ("M-S-<Return>" , addName ("\tOpen a new terminal ("++myTerminal++")") $ spawn (terminal conf))
               , ("M-d"          , addName "\tLaunch Doom Emacs"                        $ spawn doom_emacsclient)
               , ("M-v"          , addName "\tLaunch vanilla Emacs"                     $ spawn vanilla_emacsclient)
               ]
  , KeySection "Layout Controls"
               [ ("M-S-<Tab>"    , addName "\tReset the window layout"             $ setLayout $ layoutHook conf)
               , ("M-<Tab>"      , addName "\tNext layout"                         $ sendMessage NextLayout)
               , ("M-S-m"        , addName "\tRotate layout by 90 degrees"         $ sendMessage $ Toggle MIRROR)
               , ("M-t s"        , addName "\tToggle gaps"                         $ toggleSpaces)
               , ("M-t b"        , addName "\tToggle borders"                      $ sendMessage $ Toggle NOBORDERS)
               , ("M-S-s"        , addName "\tSink/Tile a floating window"         $ withFocused $ windows . W.sink)
               , ("M-,"          , addName "\tIncrease windows in the master pane" $ sendMessage (IncMasterN 1))
               , ("M-."          , addName "\tDecrease windows in the master pane" $ sendMessage (IncMasterN (-1)))
               , ("M-S-n"        , addName "\tOpen a scratchpad"                   $ namedScratchpadAction scratchpads "notes")
               ]
  , KeySection "Window Controls"
               [ ("M-C-a"        , addName "\tCopy the focused window to all workspaces" $ windows copyToAll)
               , ("M-S-a"        , addName "\tKill all copies of the focused window"     $ killAllOtherCopies)
               , ("M-k"          , addName "\tFocus the next window"                     $ windows W.focusDown)
               , ("M-j"          , addName "\tFocus the previous window"                 $ windows W.focusUp)
               , ("M-<Return>"   , addName "\tSwap the focused window with the master window"   $ windows W.swapMaster)
               , ("M-S-k"        , addName "\tSwap the focused window with the next window"     $ windows W.swapDown)
               , ("M-S-j"        , addName "\tSwap the focused window with the previous window" $ windows W.swapUp)
               , ("M-h"          , addName "\tShrink window"       $ sendMessage Shrink)
               , ("M-l"          , addName "\tExpand window"       $ sendMessage Expand)
               , ("M-S-l"        , addName "\tMirrorShrink window" $ sendMessage MirrorShrink)
               , ("M-S-h"        , addName "\tMirrorExpand window" $ sendMessage MirrorExpand)
               , ("M-S-<Right>"  , addName "\tShift window to next workspace"             $ shiftToNext)
               , ("M-S-<Left>"   , addName "\tShift window to prev workspace"             $ shiftToPrev)
               , ("M-C-<Right>"  , addName "\tShift window to next workspace, then goto"  $ shiftToNext >> nextWS)
               , ("M-C-<Left>"   , addName "\tShift window to prev workspace, then goto"  $ shiftToPrev >> prevWS)
               ]
  , KeySection "Floating Layouts Controls"
               [ ("M-M1-<Left>"  , addName "\tMove window left by 10 pixels"      $ sendMessage (MoveLeft 10))
               , ("M-M1-<Right>" , addName "\tMove window right by 10 pixels"     $ sendMessage (MoveRight 10))
               , ("M-M1-<Down>"  , addName "\tMove window down by 10 pixels"      $ sendMessage (MoveDown 10))
               , ("M-M1-<Up>"    , addName "\tMove window up by 10 pixels"        $ sendMessage (MoveUp 10))
               , ("M1-C-<Left>"  , addName "\tExpand the left edge by 5 pixels"   $ sendMessage (IncreaseLeft 5))
               , ("M1-C-<Right>" , addName "\tExpand the right edge by 5 pixels"  $ sendMessage (IncreaseRight 5))
               , ("M1-C-<Down>"  , addName "\tExpand the bottom edge by 5 pixels" $ sendMessage (IncreaseDown 5))
               , ("M1-C-<Up>"    , addName "\tExpand the top edge by 5 pixels"    $ sendMessage (IncreaseUp 5))
               , ("M1-S-<Left>"  , addName "\tShrink the left edge by 5 pixels"   $ sendMessage (DecreaseLeft 5))
               , ("M1-S-<Right>" , addName "\tShrink the right edge by 5 pixels"  $ sendMessage (DecreaseRight 5))
               , ("M1-S-<Down>"  , addName "\tShrink the bottom edge by 5 pixels" $ sendMessage (DecreaseDown 5))
               , ("M1-S-<Up>"    , addName "\tShrink the top edge by 5 pixels"    $ sendMessage (DecreaseUp 5))
               ]
  , KeySection "Workspace Controls"
               [ ("M-<Right>"    , addName "\tGoto next workspace"                $ nextWS)
               , ("M-<Left>"     , addName "\tGoto previous workspace"            $ prevWS)
               , ("M-1"          , addName ("\tGoto workspace 1")                 $ windows $ W.greedyView $ ws !! 0)
               , ("M-2"          , addName ("\tGoto workspace 2")                 $ windows $ W.greedyView $ ws !! 1)
               , ("M-3"          , addName ("\tGoto workspace 3")                 $ windows $ W.greedyView $ ws !! 2)
               , ("M-4"          , addName ("\tGoto workspace 4")                 $ windows $ W.greedyView $ ws !! 3)
               , ("M-5"          , addName ("\tGoto workspace 5")                 $ windows $ W.greedyView $ ws !! 4)
               , ("M-6"          , addName ("\tGoto workspace 6")                 $ windows $ W.greedyView $ ws !! 5)
               , ("M-7"          , addName ("\tGoto workspace 7")                 $ windows $ W.greedyView $ ws !! 6)
               , ("M-S-1"        , addName ("\tShift window to workspace 1")      $ windows $ W.shift $ ws !! 0)
               , ("M-S-2"        , addName ("\tShift window to workspace 2")      $ windows $ W.shift $ ws !! 1)
               , ("M-S-3"        , addName ("\tShift window to workspace 3")      $ windows $ W.shift $ ws !! 2)
               , ("M-S-4"        , addName ("\tShift window to workspace 4")      $ windows $ W.shift $ ws !! 3)
               , ("M-S-5"        , addName ("\tShift window to workspace 5")      $ windows $ W.shift $ ws !! 4)
               , ("M-S-6"        , addName ("\tShift window to workspace 6")      $ windows $ W.shift $ ws !! 5)
               , ("M-S-7"        , addName ("\tShift window to workspace 7")      $ windows $ W.shift $ ws !! 6)
               , ("M-C-1"        , addName ("\tCopy window to workspace 1")       $ windows $ copy $ ws !! 0)
               , ("M-C-2"        , addName ("\tCopy window to workspace 2")       $ windows $ copy $ ws !! 1)
               , ("M-C-3"        , addName ("\tCopy window to workspace 3")       $ windows $ copy $ ws !! 2)
               , ("M-C-4"        , addName ("\tCopy window to workspace 4")       $ windows $ copy $ ws !! 3)
               , ("M-C-5"        , addName ("\tCopy window to workspace 5")       $ windows $ copy $ ws !! 4)
               , ("M-C-6"        , addName ("\tCopy window to workspace 6")       $ windows $ copy $ ws !! 5)
               , ("M-C-7"        , addName ("\tCopy window to workspace 7")       $ windows $ copy $ ws !! 6)

               ]
  , KeySection "Gap Controls"
               [ ("M-s i"        , addName "\tIncrease gap size by 5 pixels"      $ incScreenWindowSpacing 5)
               , ("M-s d"        , addName "\tdecrease gap size by 5 pixels"      $ decScreenWindowSpacing 5)
               , ("M-s r"        , addName "\tReset gap size to `defaultGapSize`" $ setScreenWindowSpacing 10)
               ]
  ]
     where
          ws = workspaces conf

myKeys conf = concatMap (\(KeySection title keys) -> subTitle title keys) (myKeysSections conf)
      where
        subTitle str keys = (subtitle str) : mkNamedKeymap conf keys



toggleSpaces :: X ()
toggleSpaces = toggleScreenSpacingEnabled >> toggleWindowSpacingEnabled

myMouseBindings :: XConfig l -> M.Map (KeyMask, Button) (Window -> X ())
myMouseBindings XConfig {XMonad.modMask = modm} =
  M.fromList
    [ ((modm, button1)                 , \w -> focus w >> mouseMoveWindow w >> windows W.shiftMaster )
    , ((modm .|. controlMask, button1) , \w -> focus w >> windows W.shiftMaster)
    , ((modm .|. shiftMask, button1)   , \w -> focus w >> mouseResizeWindow w >> windows W.shiftMaster)
    ]
#+end_src
*** Utility Functions
#+begin_src haskell
yad = "yad --undecorated --no-buttons --text-info --text-align=left --fontname=\"Hack 12\" --fore="
    ++ colorBBlue theme ++ " --back=" ++ colorBlack theme ++ " --geometry=1400x800"

pipeToYad str = do
            yadPipe <- spawnPipe yad
            hPutStrLn yadPipe str
            hClose yadPipe
            return ()


yadShowKeymaps x = addName "Show Keybindings" . io . pipeToYad . unlines . showKm $ x

yadCheckKeymap conf km = warn (doKeymapCheck conf km)
  where warn ([],[])   = return ()
        warn (bad,dup) = io . pipeToYad $ "Warning:\n"
                            ++ msg "bad" bad ++ "\n"
                            ++ msg "duplicate" dup
        msg _ [] = ""
        msg m xs = m ++ " keybindings detected: " ++ showBindings xs
        showBindings = unwords . map (("\""++) . (++"\""))

doKeymapCheck conf km = (bad,dups)
  where ks = map ((readKeySequence conf &&& id) . fst) km
        bad = nub . map snd . filter (isNothing . fst) $ ks
        dups = map (snd . head)
             . filter ((>1) . length)
             . groupBy ((==) `on` fst)
             . sortBy (comparing fst)
             . map (first fromJust)
             . filter (isJust . fst)
             $ ks
#+end_src


** Main
A structure containing your configuration settings, overriding fields in the default config. Any you don't override, will use the defaults defined in xmonad/XMonad/Config.hs

#+begin_src haskell

main :: IO ()
main = do
    xmonad
      . withSB mySB
      . docks
      . ewmhFullscreen
      . ewmh
      $ addDescrKeys' ((mod4Mask, xK_F1), yadShowKeymaps) myKeys myXConfig

myXConfig = def
  { terminal = myTerminal
  , focusFollowsMouse = myFocusFollowsMouse
  , clickJustFocuses = myClickJustFocuses
  , borderWidth = myBorderWidth
  , modMask = myModMask
  , workspaces =  myWorkspaces
  , normalBorderColor = myNormalBorderColor
  , focusedBorderColor = myFocusedBorderColor
  -- , keys = myKeys
  , mouseBindings = myMouseBindings
  , layoutHook = myLayout
  , manageHook = myManageHook
  , handleEventHook = myEventHook
  , logHook = myLogHook
  , startupHook = myStartupHook
  }

#+end_src
------
* XMobar
XMobar is a status bar written in haskell and can be used as a library for creating custom status bars.


#+begin_src haskell :tangle src/xmobar.hs

  -- Builtin
import Text.Printf as P

  -- Basic
import Xmobar

  -- MyLib
import Color.Theme

#+end_src
** Utils
#+begin_src haskell :tangle src/xmobar.hs

box :: String -> String -> String -> Int -> (Int, Int, Int, Int) -> String
box str ty color width (mt, mb, ml, mr) =
  P.printf "<box type=%s width=%d mt=%d mb=%d ml=%d mr=%d color=%s > %s </box> " ty width mt mb ml mr color str

dtBox str ty color = box str ty color 3 (0,0,0,0)

colorize ::String -> String ->String
colorize color str = "<fc=" ++ color ++ ">" ++ str ++"</fc>"

fontSize :: Int->String->String
fontSize i str = "<fn="++show i++ ">"++ str ++ "</fn>"

action command str = "<action=`"++command ++ "`>" ++ str ++"</action>"

#+end_src

** Fonts
#+begin_src haskell :tangle src/xmobar.hs
fontList = [ (1,"Hack Bold 14")
           , (2,"Hack Bold Italic 14")
           , (3,"Hack Bold 12")
           , (4,"Hack Bold Italic 12")
           , (5,"Hack Bold 10")
           , (6,"Hack Bold Italic 10")
           , (7,"Hack Bold 8")
           , (8,"Hack Bold Italic 8")
           , (9,"Hack 8")
           ]
#+end_src

** Monitors
#+begin_src haskell :tangle src/xmobar.hs

class MyMonitor a where
  def :: a -> [(String, String)]
  def = const []

  monitorSpecific :: a -> [(String, String)]
  monitorSpecific  = const []

  monitorTemplate :: a -> String
  monitorTemplate = const ""

  toArgs :: a -> [String]
  toArgs a = concatMap (\(x, y) -> [x, y]) (def a ++ monitorSpecific a)

#+end_src
*** Battery
#+begin_src haskell :tangle src/xmobar.hs

data MyBattery = MyBattery
battery = BatteryP ["BAT1"] (toArgs MyBattery) 360

instance MyMonitor MyBattery where
  def =
    const
      [ ("-t", "<acstatus><left>%"),
        ("-L", "20"),
        ("-H", "80"),
        ("-p", "3")
      ]
  monitorSpecific =
    const
      [ ("--", ""),
        ("-i", "<fc=#0088aa>Full</fc>"), -- idle AC, fully charged
        ("-O", "\x1F50C"), -- \xf583"   -- On AC, charging
        ("-o", "<fc=#33aa55><fn=1>\xf242 </fn></fc>"),  -- off AC, discharging
        ("-p", "green"),
        ("-A", "30"),
        ("-a", "notify-send -u critical 'Battery is running out!'")
      ]
  monitorTemplate = const
                  $ fontSize 6
                  $ colorize "#ee33bb"
                  $ dtBox "%battery%"  "Bottom" "#ee33bb"

#+end_src

*** Brightness
#+begin_src haskell :tangle src/xmobar.hs

data MyBrightness = MyBrightness
brightness = Brightness (toArgs MyBrightness) 1

instance MyMonitor MyBrightness where
  def =
    const
      [ ("-t", "<bar>"),
        ("-W", "10"),
        ("-b", " "), -- \x1fb8f
        ("-f", "\x1fb39") 
      ]
  monitorSpecific =
    const
      [ ("--", ""),
        ("-D", "intel_backlight"),
        ("-C", "actual_brightness"),
        ("-M", "max_brightness")
      ]
  monitorTemplate = const
                  $ fontSize 6
                  $ colorize "#dfaa11" -- "#fffa55"
                  $ dtBox "%bright%" "Bottom" "#dfaa11" -- <fn=1>\x1f317</fn>
#+end_src
*** CPU
#+begin_src haskell :tangle src/xmobar.hs
data MyCpu = MyCpu
cpu = MultiCpu (toArgs MyCpu) 50
instance MyMonitor MyCpu where
  def =
    const
      [ ("-t", "<total>%"),
        ("-L", "5"),
        ("-H", "50"),
        ("-l", "#ff8855"),
        ("-h", "red")
      ]
  monitorTemplate = const
                  $ action "st -e btop"
                  $ fontSize 6
                  $ colorize "#ff8855"
                  $ dtBox "<fn=1>\xf26c</fn>  cpu:%multicpu%" "Bottom" "#ff8855"

  #+end_src
*** CPUTemp
#+begin_src haskell :tangle src/xmobar.hs
data MyTemp = MyTemp
temperature = MultiCoreTemp (toArgs MyTemp) 50
instance MyMonitor MyTemp where
  def =
    const
      [ ("-t", "temp:<avg>\x2103"),
        ("-L", "60"),
        ("-H", "80"),
        ("-l", "#ff647f"),
        ("-h", "red")
      ]
  monitorSpecific =
    const
      [ ("--" , ""),
        ("--mintemp","20"),
        ("--maxtemp","100")
      ]
  monitorTemplate = const
                  $ fontSize 6
                  $ colorize "#ff647f"
                  $ dtBox "%multicoretemp%" "Bottom" "#ff647f"

#+end_src
*** Memory
#+begin_src haskell :tangle src/xmobar.hs

data MyMemory = MyMemory
memory = Memory (toArgs MyMemory) 20

instance MyMonitor MyMemory where
  def = const [("-t", "<used>mb(<usedratio>%)")]
  monitorTemplate = const
                  $ fontSize 6
                  $ colorize "#ff6600"
                  $ dtBox "mem:%memory%" "Bottom" "#ff6600"

#+end_src
*** Updates
#+begin_src haskell :tangle src/xmobar.hs
checkUpdates = Com "/bin/bash" ["-c","{ checkupdates & yay -Qua; } | wc -l"] "updates" 36000
checkUpdatesTemplate = action "$XDG_CONFIG_HOME/xmonad/scripts/yadUpdates"
                $ fontSize 6
                $ colorize "#ff0000"
                $ dtBox "\xf0f3 %updates% updates" "Bottom" "#ff0000"
#+end_src
*** Trayer
#+begin_src haskell :tangle src/xmobar.hs
trayer = Com "/bin/bash" [ "-c", "$XDG_CONFIG_HOME/xmonad/scripts/icon_padding" ] "trayerpad" 10
trayerTemplate = "%trayerpad%"
#+end_src
*** Date
#+begin_src haskell :tangle src/xmobar.hs
datetime = Date "%b %d %Y-<fc=#00d5c8>%I:%M</fc>" "date" 10
dateTemplate = fontSize 6
             $ colorize "#e0a5ff"
             $ dtBox "<fn=5>\x1f551</fn> %date%" "Bottom" "#e0a5ff"
#+end_src
*** Kbd
#+begin_src haskell :tangle src/xmobar.hs
kbd = Kbd []
kbdTemplate = colorize "#ff85ac"
            $ fontSize 6
            $ dtBox "\x2328 %kbd%" "Bottom" "#ff85ac"
#+end_src
** Main
#+begin_src haskell :tangle src/xmobar.hs

main :: IO ()
main = xmobar config

config :: Config
config =
  defaultConfig
    {
      template =
        " <icon=haskell.xpm/> %UnsafeXMonadLog% }{"
        ++ checkUpdatesTemplate
        ++ monitorTemplate MyBrightness
        ++ monitorTemplate MyTemp
        ++ monitorTemplate MyMemory
        ++ monitorTemplate MyCpu
        ++ dateTemplate
        ++ kbdTemplate
        ++ monitorTemplate MyBattery
        ++ trayerTemplate,

      font = "Hack Bold Italic 12",
      position = TopHM 30 10 10 5 5, -- Height, left/right margins, top/down margins
      additionalFonts = map snd fontList,
      allDesktops = True,
      alpha = 255,
      bgColor = colorBack theme,
      fgColor = colorFore theme,
      iconRoot = "/home/karim/.config/xmonad/icons",
      commands =
        [ Run UnsafeXMonadLog
        , Run memory
        , Run kbd
        , Run brightness
        , Run battery
        , Run datetime
        , Run trayer
        , Run cpu
        , Run temperature
        , Run checkUpdates
       ],
      alignSep = "}{",
      sepChar  = "%"
    }
#+end_src
